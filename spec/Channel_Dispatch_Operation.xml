<?xml version="1.0" ?>
<node name="/Channel_Dispatch_Operation"
  xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">

  <tp:copyright>Copyright (C) 2008 Collabora Ltd.</tp:copyright>
  <tp:copyright>Copyright (C) 2008 Nokia Corporation</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
      modify it under the terms of the GNU Lesser General Public
      License as published by the Free Software Foundation; either
      version 2.1 of the License, or (at your option) any later version.</p>

    <p>This library is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
      Lesser General Public License for more details.</p>

    <p>You should have received a copy of the GNU Lesser General Public
      License along with this library; if not, write to the Free Software
      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
      MA 02110-1301, USA.</p>
  </tp:license>

  <interface name="org.freedesktop.Telepathy.ChannelDispatchOperation.DRAFT"
    tp:causes-havoc="experimental">

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A channel dispatch operation is an object in the ChannelDispatcher
        representing a bundle of unrequested channels being announced to
        client processes.</p>

      <p>These objects can result from new incoming channels or channels
        which are automatically created for some reason, but cannot result
        from outgoing requests for channels.</p>

      <p>More specifically, whenever the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.DRAFT.NewChannels</tp:dbus-ref>
        signal contains channels whose
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.FUTURE.Requested</tp:dbus-ref>
        property is false, or whenever the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.NewChannel</tp:dbus-ref>
        signal contains a channel with suppress_handler false,
        one or more ChannelDispatchOperation objects are created for those
        channels.</p>

      <p>(If some channels in a NewChannels signal are in different bundles,
        this is an error. The channel dispatcher SHOULD recover by treating
        the NewChannels signal as if it had been several NewChannels signals
        each containing one channel.)</p>

      <p>First, the channel dispatcher SHOULD construct a list of all the
        channel handlers that could handle all the channels, ordered by
        priority in some implementation-dependent way. If there are handlers
        which could handle all the channels, one channel dispatch operation
        SHOULD be created for all the channels. If there are not, one channel
        dispatch operation SHOULD be created for each channel, each with
        a list of channel handlers that could handle that channel.</p>

      <p>When listing channel handlers, priority SHOULD be given to
        channel handlers that are already handling channels from the same
        bundle.</p>

      <p>Processing of a channel dispatch operation proceeds as follows.
        If the channels in a channel dispatch operation are in the same
        bundle as a channel that is already being handled, and the handler
        could also handle the channels being dispatched, the channel
        dispatcher SHOULD call the handler's
        HandleAdditionalChannels
        method to see whether the handler will accept the new channels too.
        If the handler takes responsibility for the channels,
        processing stops, and no approvers are run.</p>

      <p>(FIXME: this is far too subtle and everyone will get it wrong.
        Open issue: how else do we address this use case?)</p>

      <tp:rationale>
        <p>Some channel types can be picked up "quietly" by an existing
          channel handler. If a Text channel is added to an existing
          bundle containing a StreamedMedia channel, there shouldn't be
          any approvers, flashing icons or notification bubbles, if the
          the UI for the StreamedMedia channel can just add a text box
          and display the message.</p>
      </tp:rationale>

      <p>If not, the channel dispatcher SHOULD send the channel dispatch
        operation to all relevant approvers (in parallel) and wait for an
        approver to claim the channels or request that they are handled.</p>

      <p>Finally, if the approver requested it, the channel dispatcher SHOULD
        send the channels to a handler.</p>
    </tp:docstring>

    <property name="Interfaces" type="as" access="read"
      tp:type="DBus_Interface[]">
      <tp:docstring>
        A list of the extra interfaces provided by this channel dispatch
        operation.
      </tp:docstring>
    </property>

    <method name="HandleWith">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Called by an approver to accept a channel bundle and request that
          the given handler be used to handle it.</p>

        <p>If successful, this method will cause the ChannelDispatchOperation
          object to disappear, emitting
          <tp:member-ref>Closed</tp:member-ref>.</p>

        <p>However, this method may fail because the dispatch has already been
          completed and the object has already gone. If this occurs, it
          indicates that another approver has asked for the bundle to be
          handled by a particular handler. The approver MUST NOT attempt
          to handle the channels itself in this case.</p>

        <p>Approvers which are also channel handlers SHOULD use Claim instead
          of HandleWith to request that they can handle a channel bundle
          themselves.</p>

        <p>(FIXME: list some possible errors)</p>

        <p>(FIXME: should the Approver be able to direct individual channels
          to different handlers?)</p>
      </tp:docstring>

      <arg direction="in" type="s" tp:type="DBus_Bus_Name" name="Handler">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The well-known bus name (starting with
            <code>org.freedesktop.Telepathy.Client.</code>) of the channel
            handler that should handle the channel.</p>
        </tp:docstring>
      </arg>

    </method>

    <method name="Claim">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Called by an approver to claim a channel bundle for handling
          internally. The process calling this method becomes the handler for
          the channel, but <em>does not</em> have the HandleChannels method
          called on it.</p>
        <!-- FIXME: tp:dbus-ref -->

        <p>Clients that call Claim on a channel and do not immediately
          close it SHOULD implement the Handler interface and its
          CurrentlyHandledChannels property.</p>
        <!-- FIXME: tp:dbus-ref -->

        <p>Approvers wishing to reject a channel MUST call this method to
          claim ownership of it, and MUST NOT call
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">Close</tp:dbus-ref>
          on the channel unless this method returns successfully.</p>

        <tp:rationale>
          <p>The channel dispatcher can't know how best to close arbitrary
            channel types (for instance, for Text channels it is necessary
            to acknowledge any messages that have already been displayed to
            the user first), so it leaves it up to the approver to do so.</p>
        </tp:rationale>

        <p>If successful, this method will cause the ChannelDispatchOperation
          object to disappear, emitting
          <tp:member-ref>Closed</tp:member-ref>, in the same way as for
          <tp:member-ref>HandleWith</tp:member-ref>.</p>

        <p>This method may fail because the dispatch operation has already
          been completed. Again, see HandleWith for more details. The approver
          MUST NOT attempt to close the channels itself in this case.</p>

        <p>(FIXME: list some possible errors)</p>

        <p>(FIXME: should it be possible to Claim individual channels?)</p>
      </tp:docstring>

    </method>

    <signal name="Closed">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Emitted when this dispatch operation finishes. The dispatch
          operation is no longer present and further methods must not be
          called on it.</p>

        <p>Its object path SHOULD NOT be reused for a subsequent dispatch
          operation; the ChannelDispatcher MUST choose object paths
          in a way that avoids immediate re-use.</p>

        <tp:rationale>
          <p>Otherwise, clients might accidentally call HandleWith or Claim
            on a new dispatch operation instead of the one they
            intended to handle.</p>
        </tp:rationale>
      </tp:docstring>
    </signal>

  </interface>
</node>
<!-- vim:set sw=2 sts=2 et ft=xml: -->
