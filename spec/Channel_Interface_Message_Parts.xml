<?xml version="1.0" ?>
<node name="/Channel_Interface_Message_Parts"
  xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
  <tp:copyright>Copyright (C) 2008 Collabora Ltd.</tp:copyright>
  <tp:copyright>Copyright (C) 2008 Nokia Corporation</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.MessageParts">
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Type.Text"/>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>This interface extends the Text interface to support messages with
        attachments (like MIME multipart/mixed) and alternatives (like MIME
        multipart/alternative); it also provides a hook for improved sent
        message status notification, to be used by a future
        DeliveryNotification interface.</p>

      <p>Although this specification supports formatted (rich-text)
        messages with unformatted alternatives, implementations SHOULD NOT
        attempt to use formatted messages until the Telepathy specification
        has also been extended to cover capability discovery for message
        formatting.</p>

      <tp:rationale>
        We intend to expose all rich-text messages as XHTML-IM, but on some
        protocols, formatting is an extremely limited subset of that format
        (e.g. there are protocols where foreground/background colours, font
        and size can be set, but only for entire messages).
        Until we can tell UIs what controls to offer to the user, it's
        unfriendly to offer the user controls that may have no effect.
      </tp:rationale>
    </tp:docstring>

    <property name="SupportedContentTypes" type="as" access="read">
      <tp:docstring>
        A list of MIME types supported by this channel, with more preferred
        MIME types appearing earlier in the list. The list MAY include "*/*"
        to indicate that attachments with arbitrary MIME types can be sent.
        If the list is empty, this indicates that messages may only include
        a single "text/plain" part.
      </tp:docstring>
    </property>

    <property name="MessagePartSupportFlags" type="u"
      tp:type="Message_Part_Support_Flags"
      access="read">
      <tp:docstring>
        Flags indicating the level of support for message parts on this
        channel.
      </tp:docstring>
    </property>

    <tp:flags name="Message_Part_Support_Flags"
      value-prefix="Message_Part_Support_Flag">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Flags indicating the level of support for message parts on this
          channel. They are designed such that setting more flags always
          implies that the channel has more capabilities.</p>

        <p>It is assumed that messages containing a textual message body
          (only) are always supported.</p>

        <p>There is no flag indicating support for alternatives. This is
          because the SendMessage implementation can always accept messages
          containing alternatives, even if the underlying protocol does not,
          by deleting all alternatives except the first (most preferred)
          that is supported.</p>
      </tp:docstring>

      <tp:flag suffix="Data_Only" value="1">
        <tp:docstring>
          SendMessage will accept messages containing a single part of any
          type listed in the SupportedContentTypes property, with no
          accompanying text.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="One_Attachment" value="2">
        <tp:docstring>
          SendMessage will accept messages containing a textual message body,
          plus a single attachment of any type listed in the
          SupportedContentTypes property. It does not make sense for this
          flag to be set if Message_Part_Support_Flag_Data_Only is not also set
          (because the connection manager can trivially provide an empty text
          part if necessary).
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Multiple_Attachments" value="4">
        <tp:docstring>
          SendMessage will accept messages containing a textual message body,
          plus an arbitrary number of attachments of any type listed in the
          SupportedContentTypes property. It does not make sense for this
          flag to be set if Message_Part_Support_Flag_One_Attachment is not
          also set.
        </tp:docstring>
      </tp:flag>
    </tp:flags>

    <tp:struct name="Multiple_Part_Message"
      array-name="Multiple_Part_Message_List">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Mapping representing a message which can have multiple parts
          (for example, a message with attached data, or a message with
          plain-text and XHTML alternatives).</p>

        <p>Messages containing a human-readable text message (as handled
          by the Text channel type) MUST include a part with type
          "text/plain", which MAY have an alternative that uses formatted
          text.</p>

        <p>Messages containing a non-empty part with type "text/plain" MUST
          be signalled (redundantly) via the Text channel type, with the
          same message ID (if incoming) and content.</p>

        <p>Conversely, for every message signalled via the
          Text channel type, there MUST be a corresponding multi-part message
          with the same message ID (if incoming), and with a "text/plain"
          part with the same content (it need not have any other parts),
          in this interface.</p>
      </tp:docstring>

      <tp:member type="u" tp:type="Unix_Timestamp" name="Timestamp">
        <tp:docstring>
          The time the message was sent (if available) or received (if the
          time it was sent is not available).
        </tp:docstring>
      </tp:member>

      <tp:member type="u" tp:type="Contact_Handle" name="Sender">
        <tp:docstring>
          The contact who sent the message.
        </tp:docstring>
      </tp:member>

      <tp:member type="u" tp:type="Channel_Text_Message_Type"
        name="Message_Type">
        <tp:docstring>
          The type of message.
        </tp:docstring>
      </tp:member>

      <tp:member type="aa{sv}" tp:type="Message_Part[]" name="Content">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The message content, including any attachments or
            alternatives.</p>

          <p>In any group of parts with the same identifier (which
            represent alternative versions of the same content),
            more faithful versions of the intended message MUST come before
            less faithful versions (note that this order is the opposite of
            MIME "multipart/alternative" parts). Clients SHOULD display the
            first alternative that they understand.</p>

          <tp:rationale>
            Specifying the preference order means that if the underlying
            protocol doesn't support alternatives, the CM can safely delete
            everything apart from the first supported alternative when sending
            messages.
          </tp:rationale>

          <p>An example of how the Content member of a message might
            look, in a Python-like syntax:</p>

          <pre>
[
  { 'identifier': 'main',
    'type': 'text/html',
    'text': 'Here is a photo of my cat:&lt;br /&gt;' +
            '&lt;img src="cid:catphoto" alt="lol!" /&gt;' +
            '&lt;br /&gt;Isn't it cute?',
  },
  { 'identifier': 'main',
    'type': 'text/plain',
    'text': 'Here is a photo of my cat:\n[IMG: lol!]\nIsn't it cute?',
  },
  { 'identifier': 'catphoto',
    'type': 'image/jpeg',
    'size': 101000,
    'needs-retrieval': True,
  },
]
          </pre>

          <p>Clients SHOULD present all parts that have distinct identifiers,
            in the order they appear in this array, possibly excluding parts
            that are referenced by another displayed part. It is
            implementation-specific how the parts are presented to the
            user.</p>

          <tp:rationale>
            <p>This allows CMs to assume that all parts are actually shown to
              the user, even if they are not explicitly referenced - we do
              not yet recommend formatted text, and there is no way for
              plain text to reference an attachment since it has no concept of
              markup or references. This also forces clients to do something
              sensible with messages that consist entirely of "attachments",
              with no "body" at all.</p>

            <p>For instance, when displaying the above example, a client that
              understands the HTML part should display the JPEG image once,
              between the two lines "Here is a photo of my cat:" and
              "Isn't it cute?"; it may additionally present the image in some
              way for a second time, after "Isn't it cute?", or may choose
              not to.</p>

            <p>A client that does not understand HTML, displaying the same
              message, should display the plain-text part, followed by the JPEG
              image.</p>
          </tp:rationale>
        </tp:docstring>
      </tp:member>
    </tp:struct>

    <tp:mapping name="Message_Part" array-name="Message_Part_List">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Part of a message's content.</p>

        <p>For the 'content' key, "sufficiently small to include" is not
          currently defined; we should add some API so clients can tell the
          CM how large a message it should emit in the signal.</p>
      </tp:docstring>

      <tp:member name="Key" type="s">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>Well-known keys, and the corresponding value types, include:</p>

          <dl>
            <dt>identifier (s)</dt>
            <dd>An opaque identifier for this part.
              All parts of the same message with the same identifier are
              alternatives, and clients SHOULD only display one of them
              (this is expected to be used for XHTML messages in a future
              version of this specification). All parts with distinct
              identifiers SHOULD be presented by clients. This key is optional;
              if omitted, clients MUST behave as if each part without
              an identifier had a unique identifier.
              Parts of a message MAY reference other parts by treating
              this identifier as if it were a MIME Content-ID and using
              the cid: URI scheme.</dd>

            <dt>type (s)</dt>
            <dd>
              <p>The MIME type of this part. See the documentation
                for ReceivedMessage for notes on the special status of
                "text/plain" parts.</p>

              <p>Connection managers MUST NOT signal parts without a 'type'
                key; if a protocol provides no way to determine the MIME type,
                the connection manager is responsible for guessing it, but
                MAY fall back to "text/plain" for text and
                "application/octet-stream" for non-text.</p>

              <p>Clients MUST ignore parts without a 'type' key, which are
                reserved for future expansion.</p>

              <tp:rationale>
                <p>The Multiple_Part_Message structure is not extensible,
                  to keep its nesting depth manageable. If we need message-wide
                  extensions in future, we can use parts without a 'type'
                  key.</p>
              </tp:rationale>
            </dd>

            <dt>lang (s)</dt>
            <dd>The natural language of this part, identified by a
              RFC 3066 language tag.

              <tp:rationale>
                XMPP allows alternative-selection by language as well as
                by content-type.
              </tp:rationale>
            </dd>

            <dt>size (u)</dt>
            <dd>The size in bytes (if needs-retrieval is true, this MAY be an
              estimated or approximate size). SHOULD be omitted if 'content'
              is provided.

              <tp:rationale>
                There's no point in providing the size if you're already
                providing all the content.
              </tp:rationale>
              </dd>

            <dt>needs-retrieval (b)</dt>
            <dd>If false or omitted, the connection
              manager already holds this part in memory. If present and true,
              this part will be retrieved on demand (like MIME's
              message/external-body), so clients should expect retrieval to
              take time; if this specification is later extended to provide a
              streaming version of GetPendingMessageContent, clients should
              use it for parts with this flag.</dd>

            <dt>truncated (b)</dt>
            <dd>The content available via the 'content' key or
              GetPendingMessageContent has been truncated by the server
              or connection manager (equivalent to
              Channel_Text_Message_Flag_Truncated in the Text interface).
            </dd>

            <dt>content (s or ay)</dt>
            <dd>The part's content, if it is available and
              sufficiently small to include here (implies that
              'needs-retrieval' is false or omitted). Otherwise, omitted.
              If the part is human-readable text or HTML, the value for this
              key MUST be a UTF-8 string (D-Bus signature 's').
              If the part is not text, the value MUST be a byte-array
              (D-Bus signature 'ay'). If the part is a text-based format
              that is not the main body of the message (e.g. an iCalendar
              or an attached XML document), the value SHOULD be a UTF-8 string,
              transcoding from another charset to UTF-8 if necessary, but
              MAY be a byte-array (of unspecified character set) if
              transcoding fails or the source charset is not known.</dd>
          </dl>

        </tp:docstring>
      </tp:member>

      <tp:member name="Value" type="v">
        <tp:docstring>
          The value corresponding to the given key, which must be of one of
          the types indicated.
        </tp:docstring>
      </tp:member>
    </tp:mapping>


  </interface>
</node>
<!-- vim:set sw=2 sts=2 et ft=xml: -->
