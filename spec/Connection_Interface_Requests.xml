<?xml version="1.0" ?>
<node name="/Connection_Interface_Requests"
  xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0"
  >
  <tp:copyright>Copyright (C) 2008 Collabora Limited</tp:copyright>
  <tp:copyright>Copyright (C) 2008 Nokia Corporation</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
<p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Connection.Interface.Requests.DRAFT"
    tp:causes-havoc="experimental">
    <tp:requires interface="org.freedesktop.Telepathy.Connection"/>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>An enhanced version of the Telepathy connection interface, which can
        represent bundles of channels that should be dispatched together, and
        does not assume any particular properties by which channels are
        uniquely identifiable.</p>

      <p>New in 0.17.UNRELEASED.</p>
    </tp:docstring>

    <tp:flags name="Channel_Announcement_Flags"
      value-prefix="Channel_Announcement_Flag">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Flags that can appear when new channels are announced or when
          RequestChannels returns.</p>
      </tp:docstring>

      <!-- FIXME: this is per-channel, not per-announcement! -->
      <tp:flag name="Reused" value="1">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The channel already existed (and should be assumed to have been
            handled) before the request was made. This flag MUST NOT appear
            in NewChannels signals (where the channels are always new)
            or the Channels property (where the channels always already exist)
            - it only makes sense to return it from RequestChannels.</p>
        </tp:docstring>
        <!-- FIXME: do we actually need this flag, or is the significant thing
        really whether this client is the channel handler for the channel
        (which is a ChannelDispatcher concept)? If this flag is really needed,
        clients can reconstruct it by tracking the connection's channels -->
      </tp:flag>

      <!-- FIXME: do something with suppress_handler? At the moment it'll
      just be fed into the Requested property, which seems fair enough -->
    </tp:flags>

    <tp:flags name="Channel_Request_Flags" value-prefix="Channel_Request_Flag">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Flags that can be set when requesting channels.</p>

        <tp:rationale>
          <p>There is deliberately no flag corresponding to the
            suppress_handler argument to
            <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.RequestChannel</tp:dbus-ref>,
            because passing a FALSE value for that argument is deprecated.
            Requests made using this interface always behave as though
            suppress_handler was TRUE.</p>
        </tp:rationale>
      </tp:docstring>

      <!-- This is per-request -->
      <tp:flag name="Prefer_Reuse" value="1">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The requesting client would prefer to re-use an existing channel
            that meets its requirements, but creating a new channel would
            also be acceptable. The default behaviour is to create a
            new channel or fail if this cannot be done.</p>

          <tp:rationale>
            <p>If only a new channel would be acceptable, clients MUST omit
              this flag. If only an existing channel would be acceptable,
              clients MUST NOT call
              <tp:member-ref>RequestChannels</tp:member-ref> at all.</p>

            <p>We can't think of a sensible use-case for clients that would
              prefer to use a new channel, but will accept an existing one if
              a new one cannot be created. If you have such a client,
              (a) let us know! and (b) you can try to make a new channel
              first, falling back to looking for an existing one in a secondary
              request.</p>
          </tp:rationale>
        </tp:docstring>
      </tp:flag>

    </tp:flags>

    <tp:struct name="Channel_Details" array-name="Channel_Details_List">
      <tp:docstring>
        Enough details of a channel that clients can work out how to dispatch
        or handle it.
      </tp:docstring>

      <tp:member name="Channel" type="o">
        <tp:docstring>
          The object path of the channel.
        </tp:docstring>
      </tp:member>
      <tp:member name="Properties" type="aa{sv}"
        tp:type="Qualified_Property_Value_Map">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>Properties of the channel.</p>

          <p>Connection managers MUST NOT include properties in this mapping
            if their values can change. Clients MUST ignore properties
            that appear in this mapping if their values can change.</p>

          <tp:rationale>
            <p>If properties that could change were included, the following
              race condition would be likely to exist in some cases:</p>

            <ul>
              <li>NewChannels or Get("Channels") includes a property P with
                value V1</li>
              <li>Client creates a proxy object for the channel</li>
              <li>The value of P changes to V2</li>
              <li>Client connects to PChanged signal</li>
              <li>Client should call Get("P") or GetAll here, to avoid the
                race, but client's author has forgotten to do so</li>
              <li>Proxy object thinks P == V1, but actually P == V2</li>
            </ul>

            <p>We've taken the opportunity to make the API encourage the
              client author to get it right. Where possible, we intend that
              properties whose value will be used in channel dispatching
              or other "early" processing will be defined so that they are
              immutable (can never change).</p>
          </tp:rationale>

          <p>Each dictionary MUST contain the keys
            <tp:dbus-ref>org.freedesktop.Telepathy.Channel.ChannelType</tp:dbus-ref>,
            <tp:dbus-ref>org.freedesktop.Telepathy.Channel.TargetHandleType</tp:dbus-ref>
            and <tp:dbus-ref>org.freedesktop.Telepathy.Channel.TargetHandle</tp:dbus-ref>.
          </p>

          <tp:rationale>
            <p>We expect these to be crucial to the channel-dispatching
              process.</p>
          </tp:rationale>
        </tp:docstring>
      </tp:member>
    </tp:struct>

    <method name="RequestChannels">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Request that channels are created.</p>
      </tp:docstring>

      <arg direction="in" name="Request_Flags" type="u"
        tp:type="Channel_Request_Flags">
        <tp:docstring>
          Flags affecting the connection manager's behaviour while satisfying
          this request.
        </tp:docstring>
      </arg>

      <arg direction="in" name="Requests" type="aa{sv}"
        tp:type="Qualified_Property_Value_Map[]">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>Dictionaries containing desirable properties. Some properties
            are defined such that only an exact match makes sense, and
            connection managers MUST NOT satisfy a request with a channel
            where that property does not match; some properties are defined
            such that the connection manager MAY treat the request as merely
            a hint, and make a best-effort attempt to satisfy it. This is
            documented separately for each property.</p>

          <p>If any of these dictionaries contains a property whose semantics
            are not known to the connection manager, this method MUST fail
            without side-effects (in particular it must not create any new
            channels).</p>

          <tp:rationale>
            <p>This is necessary if we want to be able to invent properties
              in future that, when used in a request, are hard requirements
              rather than just hints. A connection manager that did not know
              the semantics of those properties could incorrectly return a
              new channel that did not satisfy the requirements.</p>
          </tp:rationale>

          <p>The connection manager MUST NOT respond successfully,
            and SHOULD NOT create any new channels or cause any other
            side-effects, unless for each request it can produce a
            corresponding channel that satisfies the client's requirements.</p>

          <p>The connection manager SHOULD NOT return channels that do not
            have the desired handle type or handle, with the exception that
            when a particular handle is requested, the connection manager
            MAY instead return a channel with handle type Handle_Type_None
            and handle 0, which is related in some way to the requested
            handle (e.g. has the requested contact handle in its Group
            interface).</p>
        </tp:docstring>
      </arg>

      <arg name="Flags" direction="out" type="u"
        tp:type="Channel_Announcement_Flags">
        <tp:docstring>
          Flags with which the new channels were created.
        </tp:docstring>
      </arg>

      <arg name="Channels" direction="out" type="a(oa{sv})"
        tp:type="Channel_Details[]">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The channels that were produced. Although the connection manager
            will attempt to satisfy the request, they are not guaranteed to
            match what the client requested exactly; the client is responsible
            for verifying that the returned channels are suitable.</p>

          <p>The output channels MUST be in the same order as the requests.
            If the requests caused additional unrequested channels in the
            same bundle to be created as a side-effect, then this array will
            be longer than the array of requests, and the unrequested channels
            MUST appear at the end.</p>

          <tp:rationale>
            For instance, joining an XMPP MUC Tube channel requires joining
            that MUC (chatroom), which may result in the creation of an
            unrequested Text channel.
          </tp:rationale>
        </tp:docstring>
      </arg>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidHandle">
          <tp:docstring>
            The given handle does not exist or cannot be created
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            The requested channel type cannot be created with the given handle
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.Channel.Banned"/>
        <tp:error name="org.freedesktop.Telepathy.Error.Channel.Full"/>
        <tp:error name="org.freedesktop.Telepathy.Error.Channel.InviteOnly"/>
      </tp:possible-errors>
    </method>

    <signal name="NewChannels">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        New channels have been created. The connection manager SHOULD emit
        a single signal for any group of closely related channels that are
        created at the same time, so that the channel dispatcher can try to
        dispatch them to a handler as a unit.
      </tp:docstring>

      <arg name="Flags" type="u" tp:type="Channel_Announcement_Flags">
        <tp:docstring>
          Flags with which these channels were created.
        </tp:docstring>
      </arg>

      <arg name="Channels" type="a(oa{sv})" tp:type="Channel_Details[]">
        <tp:docstring>
          The channels and their details. All channels that are signalled
          together like this MUST have the same Bundle property, which may
          either refer to an existing bundle, or establish a new bundle.
        </tp:docstring>
      </arg>
    </signal>

    <property name="Channels" type="a(oa{sv})" access="read"
      tp:type="Channel_Details[]">
      <tp:docstring>
        A list of all the channels which currently exist on this connection.
        Change notification is via the NewChannels and ChannelsClosed signals.
      </tp:docstring>
    </property>

    <signal name="ChannelsClosed">
      <tp:docstring>
        Emitted when channels are closed and hence disappear from the
        Channels property.

        <tp:rationale>
          This is redundant with the Close signal on the channel itself, but
          it does provide full change notification for the Channels property.
        </tp:rationale>
      </tp:docstring>

      <arg name="Removed" type="ao">
        <tp:docstring>
          The channels which have been removed from the Channels property
        </tp:docstring>
      </arg>
    </signal>

    <tp:struct name="Channel_Class" array-name="Channel_Class_List">
      <tp:docstring>
        Structure representing a class of channels that can be requested,
        identified by a pair (channel type, handle type).
      </tp:docstring>

      <tp:member name="Channel_Type" type="s" tp:type="DBus_Interface">
        <tp:docstring>
          The channel type to be requested (a value for the
          Channel.ChannelType property)
        </tp:docstring>
      </tp:member>

      <tp:member name="Handle_Type" type="u" tp:type="Handle_Type">
        <tp:docstring>
          The handle type (a value for the Channel.TargetHandleType property)
        </tp:docstring>
      </tp:member>

      <tp:member name="Properties" type="as" tp:type="DBus_Member[]">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>Properties that can be set when requesting a channel of this
            channel type and handle type.</p>

          <p>If this array contains the Channel.Bundle property, then this
            class of channel can be combined with other channels with that
            property in a request, or added to an existing bundle. If not,
            this signifies that the connection manager is unable to mark
            channels of this class as part of a bundle - this means that
            to the remote contact they are likely to be indistinguishable
            from channels requested separately.</p>
        </tp:docstring>
      </tp:member>

      <!-- FIXME: add an "aas" of sets of mandatory parameters, from which
      clients must choose and satisfy one? I can't think of a good use-case
      though -->

      <!-- FIXME: add an "as" of interfaces that will/might be supported? -->

      <!-- FIXME: add an "a{sv}" for future expansion? :-) -->
    </tp:struct>

    <property name="AvailableChannelClasses" access="read"
      type="a(suas)" tp:type="Channel_Class[]">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The classes of channel that are expected to be available on this
          connection, i.e. those for which RequestChannels can reasonably
          be expected to succeed. User interfaces can use this information
          to show or hide UI components.</p>

        <p>This property cannot change after the connection has gone to
          state Connection_Status_Connected, so there is no change
          notification (if the connection has context-dependent capabilities,
          it SHOULD advertise support for all classes of channel that it might
          support during its lifetime). Before this state has been reached,
          the value of this property is undefined.</p>

        <tp:rationale>This is not on an optional interface, because
          connection managers can always offer some sort of clue about
          the channel classes they expect to support (at worst, they can
          announce support for everything for which they have code).
          </tp:rationale>
      </tp:docstring>
    </property>

  </interface>
</node>
<!-- vim:set sw=2 sts=2 et ft=xml: -->
