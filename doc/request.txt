Use cases for requesting channels
=================================

.. contents::

_`req3`: collaborative app
~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo is collaborating on a document with Mercutio, and wants to have a chat
embedded in his AbiWord instance, separate from any other chat with Mercutio
that may be ongoing.

:New vs. existing:
    New channel required [#]_
:Definition of channel identity:
    ChannelType is Text, TargetHandleType is CONTACT, TargetHandle is
    mercutio, Bundle is the same as the AbiWord Tube channel

.. [#] If the collaborative app already has a suitable channel, it is expected
    to work this out without the channel dispatcher's help.
    Stealing a channel from another UI is likely to fail (e.g. in the Text
    interface, they'll both try to acknowledge messages) so we should
    forbid this for sanity's sake

Current implementation: impossible, even in protocols supporting
conversation threads, because the spec can't represent them

Proposed implementation::

    let bundle_id = ...Bundle property of AbiWord Tube channel

    if a channel with TargetHandleType == CONTACT, TargetHandle == mercutio
    and Bundle == bundle_id is being handled by AbiWord:
        nothing to do, we already have a Text channel: stop

    AbiWord calls ChannelDispatcher.CreateChannel(
        account,
        {
            '...ChannelType': '...Text',
            '...TargetHandleType': CONTACT,
            '...TargetHandle': mercutio,
            '...Bundle': bundle_id,
        },
        timestamp,
        abiword_client_bus_name
    )
    AbiWord calls ChannelRequest.Proceed()

    ChannelDispatcher calls AddRequest on AbiWord, AbiWord ignores it as
        the request is already known to it

    try:
        ChannelDispatcher calls CreateChannel ({same dictionary as above})
    on success:
        channel observers run
        ChannelRequest emits Succeeded
        channel approvers do not run
        CD calls HandleChannels on AbiWord
        AbiWord handles channel
    on failure:
        ChannelDispatcher calls RemoveFailedRequest on AbiWord, and
            ChannelRequest emits Failed
        AbiWord displays failure
        if the error is the EEXIST equivalent, the message might be
            "Already talking to Mercutio in another app, and multiple threads
            are not possible in this protocol"

(Fallback behaviour if the CM is pre-Requests: the request is made with
suppress_handler = TRUE.)

_`req26`: Recovering from disconnection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo is talking to Juliet using text chat, but is disconnected due to network
instability. After reconnecting, he wants to keep using the same window to
talk to Juliet.

A solution for this use case should work correctly (and result in
a single channel) if there is a "mid-air collision" with Juliet doing the
same thing, with Juliet sending messages to Romeo while he is still
offline (on store-and-forward protocols like XMPP), or with Juliet
recovering from Romeo's disconnection as per req28_ (on protocols that
do not allow offline messages).

(Recovering from a connection manager crash is equivalent to this.)

:New vs. existing:
    ???
:Definition of channel identity:
    ChannelType is Text, TargetHandleType is CONTACT, TargetHandle is juliet,
    ThreadID is the same as before

Current implementation: same as req1_

Problems addressed by proposed implementation:

* the two conversations are unrelated (Juliet cannot distinguish
  between this case and req1_)

Proposed implementation (with a new Chan.I.Thread)::

    Romeo's chat UI (or incoming message database) automatically saves the
    ...Channel.Interface.Thread.ThreadID property of the old channel

    Disconnect/reconnect occurs

    Same as req1, except that ThreadID is included in the request

Problems remaining:

* What should the CM do if the desired thread ID cannot be used for some
  reason?

* There is a potential race, req26b_

Resolution: defer the threads spec til later,
https://bugs.freedesktop.org/show_bug.cgi?id=16544

_`req26b`: potential race
^^^^^^^^^^^^^^^^^^^^^^^^^

The same as req26_, but before Romeo's client can open the replacement
channel, Juliet sends him a message, thus opening a new channel. (This
is really a dispatching problem, but is closely related...)

The desired behaviour is that the same handler receives the channel.

Imagine that Romeo has both Kopete and Empathy installed, and Empathy
is the default, but Romeo is using Kopete to talk to Juliet.

Naive implementation: either the race is won by the request for a
replacement channel (and Kopete gets it) or it's won by Juliet's message
creating a new channel (and Empathy gets it).

Too-clever implementation: in principle, there's nothing to stop the
channel dispatcher remembering that a channel handler has lost a channel,
and using that as input to its handler-choosing heuristic

_`req27`: Resuming a conversation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo chooses a past conversation with Juliet in a log browser and wants
to resume it. (The definition of threading in XMPP expects that this is
possible.)

:New vs. existing:
    Existing channel preferred, new channel acceptable
:Definition of channel identity:
    ChannelType is Text, TargetHandleType is CONTACT, TargetHandle is juliet,
    ThreadID is the same as before

Current implementation: same as req2_

Problems addressed by proposed implementation: Juliet cannot distinguish
between this case and req2_

Proposed implementation: same as req26_, except that it resembles
req2_ instead of req1_ (i.e. no SUPPRESS_HANDLER flag)

Problems remaining: same as req26_ (including a potential race, like req26b_)

Resolution: defer the threads spec til later,
https://bugs.freedesktop.org/show_bug.cgi?id=16544

_`req28`: Recovering from other's disconnection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Juliet is talking to Romeo using text chat when Romeo is disconnected
due to network instability. The protocol is one that does not
allow offline messages to be sent, like IRC. After Romeo reconnects, Juliet
wants to keep using the same window to talk to him.

A solution for this use case should work correctly (and result in
a single channel) if there is a "mid-air collision" with Romeo doing the
same thing, or with Romeo recovering from disconnection as per req26_.

(Recovering from Romeo's connection manager crash is equivalent to this.)

Current implementation: Juliet's text channel does not close, but
she cannot send messages. When Romeo reconnects, because of 1-1 chat
uniqueness, Juliet's client continues to use the same channel and there
is no disconnection.

Proposed implementation: Juliet's client continues to use the same channel

Problems remaining: how do we ensure that?

_`req39`: message-sending UI that doesn't want to know about receiving
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A UI (perhaps an address book) allows sending one-off messages to contacts,
without entering into a dialogue. If the contact replies, this should be
dispatched as usual.

The UI can't close the channel in a race-free way, and if a message comes
in on the same channel, at that point (only) it needs dispatching to a
handler.

Similarly, imagine a text channel where sending messages is very slow:
we want to be able to close the channel handler (UI) without closing the
channel, and have the channel be re-dispatched only when a message comes in.

Possible solution: for Text channels, somehow arrange for the channel to
be re-dispatched to a "silent" handler; when an incoming message arrives,
the "silent" handler exits (or somehow submits the channel for re-dispatching)
and the CD will re-dispatch to a UI.

Possible solution: closing a Text channel that has pending messages causes
another one to open with the same pending messages

* This is in spec 0.17.9 and Gabble implements it

* Possible infinite-loop situations in Mission Control need investigating

..
  vim:set sw=4 sts=4 et:
