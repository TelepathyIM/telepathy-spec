Dispatching channels
====================

.. contents::

Incoming 1-1 text chats
-----------------------

_`dis1`: Incoming 1-1 text chat
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Juliet receives a message from Romeo that starts a new channel. Her desired
UI resembles that of Empathy and of the Nokia internet tablets:

* an icon flashes in the system tray, altering her to the incoming message
  in an unobtrusive way

* when she clicks on the icon, a chat window opens

* all incoming and outgoing messages are logged for later searching

Current implementation, _`dis1impl1`::

    NewChannel (Text, CONTACT, handle("romeo@montague.verona.fict"),
        suppress_handler=FALSE)

    Mission Control runs filters, which include the blinking "new message"
    icon in the system tray

    When the tray icon is clicked, Mission Control continues processing
    filters and eventually dispatches to the channel handler

Problems:

* We want a logger (which might be in a separate process) to be told to
  handle incoming text channels. This may require that:

  - the logger is a filter; or
  - multiple channel handlers are supported (we launch the UI and the logger
    simultaneously); or
  - the UI starts the logger (good if the UI uses the logger, e.g. is just
    a view onto the logging database); or
  - the logger starts the UI (we won't do this, it's a layering violation)

  If there is a logger, only it should be acknowledging messages (there
  will be problems if both the logger and the UI try to ack messages).
  This is conceptually rather odd if the logger is a filter.

* The logger should be started immediately, without waiting for the
  new conversation to be accepted

* As currently implemented, if MC crashes, filters are forgotten and the
  "new message" notification is skipped in future - the chat window
  pops up straight away, possibly stealing focus (bad!)

* As currently implemented, if Empathy crashes and is restarted,
  its filter will end up registered twice, so the user has to click the
  incoming message icon twice

Alternative implementation, _`dis1impl2`:

* The UI and the logger are both channel handlers, or the UI is a channel
  handler and the logger is a filter

* There is no filter, except possibly the logger

* The blinking notification icon is provided by the UI, guaranteeing
  that it always appears and that focus is never stolen

Problems with this alternative implementation:

* The chat UI may take a while to start, particularly on slow embedded
  devices; we don't really want to pay this "cost" for conversations that the
  user is going to reject anyway. This could be solved by making the primary
  UI a very small launcher which just blinks the notification icon, then
  executes the real handler as a subprocess, via exec(2) or via dlopen(3) if
  needed

_`dis2`: Incoming 1-1 text message
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Juliet receives a message from Romeo after a pause in their conversation.

Current implementation: it arrives in the Text channel

Problems:

* If Juliet's chat UI has crashed, the message is (as currently implemented)
  lost forever

* If the chat UI is not currently visible, as currently implemented it
  cannot necessarily use the same mechanism to notify the user that would
  be used for a new channel, because it doesn't "own" the notification
  mechanism for the new-channel case (this would be fixed by dis1a_)
  (call this _`dis2problem2`)

_`dis3`: Incoming 1-1 text message with window closed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After a pause in a conversation with Romeo, Juliet closes the IM window
or tab. She then receives another message from Romeo, resuming the
conversation.

Current implementation in Empathy, _`dis3impl1`:

* The Text channel is not closed

* The new message causes the chat window to pop up, possibly stealing focus

Problems:

* Focus stealing is likely

Alternative implementation, _`dis3impl2`:

* The Text channel is closed (depending on protocol, this may be visible to
  the remote user, e.g. MSN's "Juliet has closed the window")

* As a result, the new message is indistinguishable from a new channel (dis1_)

Problems:

* Not associated with the previous chat session, although this could be fixed
  with "conversation thread IDs"

* Zdra doesn't think the Chat UI should Close() text channels, although
  in ``Message-ID: <1209127037.6294.41.camel@zdra-laptop>`` he doesn't
  provide any rationale or use cases. (Zdra, could you explain please?)

Alternative implementation, _`dis3impl3`:

* the same as dis3impl1_, but use the same notification icon as for a
  new channel (dis1_), and only pop up the main chat UI window if accepted

* in practice this would give basically the same UI as for dis3impl2_, but
  without actually closing the channel

Problems:

* if it is desirable to tell the remote user that the window has been closed,
  the CM can't know

* dis2problem2_ also applies here

_`dis4`: Incoming 1-1 text chat thread
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While talking to Romeo in one IM window or tab, Juliet receives a message
from him in a separate "thread" of conversation.

Current implementation: impossible on protocols where 1-1 chats are not
just a special case of ad-hoc chatrooms, since we guarantee uniqueness
per (handle type, handle, channel type) for all handle types except NONE

_`dis5`: Incoming 1-1 text chat thread related to a VoIP call
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Juliet is talking to Romeo over VoIP; there is no text channel open between
them. Romeo sends Juliet a text chat message (e.g. to send her a URI
instead of having to spell it out verbally), which should appear in the same
UI as the VoIP call.

Current implementation: impossible, we have no representation for related
channels

_`dis6`: Incoming 1-1 text chat thread related to a collaborative app
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mercutio is collaborating on a document with Romeo using AbiWord and Tubes;
there is no text channel open between them. Romeo sends Mercutio some review
comments, which should appear in a chat UI embedded inside AbiWord.

Current implementation: impossible, we have no representation for related
channels

Invitations to named chatrooms
------------------------------

_`dis7`: Incoming named-chatroom invitation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo is invited to a named chatroom by Mercutio.

Current implementation::

    NewChannel (Text, ROOM, handle("The Capulets' ball"),
        suppress_handler=FALSE)

    Mission Control runs filters, which include the blinking "new message"
    icon in the system tray

    When the tray icon is clicked, Mission Control continues processing
    filters and eventually dispatches to the channel handler

Problems and variations: same as dis1_

Incoming VoIP calls
-------------------

_`dis8`: Incoming VoIP call
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo receives a VoIP call from Juliet. He answers.

Current implementation: similar to dis1_, but the channel has type
StreamedMedia, handle type NONE and handle 0; all the UI components must
investigate the channel's Group interface to find out who's calling.

Problems:

* The Group interface is unnecessarily complex just to find out who's calling

_`dis9`: Missed incoming VoIP call
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo receives a VoIP call from Juliet. He does not answer, and Juliet
eventually gives up and cancels the call.

Current implementation: as for dis8_

Problems:

* Information can be lost, depending on timing
  (https://bugs.freedesktop.org/show_bug.cgi?id=14606)

_`dis10`: Incoming VoIP call related to some other channel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Juliet is talking to Romeo over text chat. Romeo decides that he can't bear
to not hear her voice, and starts a VoIP call. Juliet wants controls for the
VoIP call to appear in the same UI that she's already using.

Current implementation: the call is indistinguishable from dis8_

Problems: Juliet can't get the UI she wants

Contact lists
-------------

_`dis11`: A contact list is found during login
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo logs on to an IM service. As part of the connection process,
contact list channels for the various predefined CONTACT_LIST handles,
e.g. subscribe, are created automatically by the connection manager,
as specified by the Telepathy API.

Current implementation::

    NewChannel (ContactList, LIST, handle("subscribe"),
        suppress_handler=FALSE)

    Mission Control dispatches to the channel handler

Problems:

* Can we register more than one channel handler for contact lists? Every
  process with a contact-list UI might be interested in them - or not, since
  best practice is to request the contact lists that you want to use

Best-practice solution: clients SHOULD NOT be channel handlers for contact
lists; clients SHOULD explicitly request any contact list channels that they
want to use

_`dis12`: A user-defined contact group is found during login
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo logs on to an IM service. As part of the connection process,
contact list channels are created automatically by the connection manager
for all the GROUP handles he has previously defined, as specified by the
Telepathy API.

Current implementation::

    NewChannel (ContactList, GROUP, handle("Montagues"),
        suppress_handler=FALSE)

    Mission Control dispatches to the channel handler

Problems:

* Can we register more than one channel handler for groups? Every process
  with a contact-list UI might be interested in them

Possible solution: in processes with a contact-list UI, use the
AccountManager API to find active connections, then use
NewChannel/ListChannels to find any (ContactList, GROUP) channels

_`dis13`: A user-defined contact group is created
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Romeo is connected to the same XMPP account using his PC and his N800.
He uses the PC to create a contact group, "My true love", and adds Juliet
to it. On the N800 he expects the new group to appear automatically.

Current implementation::

    NewChannel (ContactList, GROUP, handle("My true love"),
        suppress_handler=FALSE)

    Mission Control dispatches to the channel handler

Problems: same as dis12_

Possible solution: same as dis12_

Invitations to ad-hoc chatrooms
-------------------------------

FIXME: there are quite a few cases here.

File transfers
--------------

FIXME: ... are hard

Tubes
-----

FIXME: ... are hard (see also, OLPC's Activity model)

..
  vim:set sw=4 sts=4 et:
